---
layout: post
title: 排序算法大杂烩
tags: [Data Structures, Algorithm]
bigimg: /img/path.jpg
comments: true
---

* toc
{:toc}

# 排序的概念

排序分为内部排序和外部排序，内部排序中，排序用的数据都在主存内，外部排序则可能存在在磁盘或者远端，访问数据需要进行I/O。

排序的稳定性是指数组中存在相同值得元素，在完成排序后，其前后相对位置不会发生变化。

| 稳定的排序算法 | 不稳定的排序算法 |
| :----------- |:------------- |
| 插入排序 | 选择排序 |
| 冒泡排序 | 快速排序 |
| 归并排序 | 堆排序   |

下面用Golang分别演示排序算法，为了简化讨论，本文中排序的目标都是升序。

# 比较排序

假设N是参与排序的元素个数，在内部排序中，存在几种直观的比较排序算法，插入排序、选择排序和冒泡排序，它们的时间复杂度为$$ O(N^2) $$。

行内公式 $$ E=mc^2 $$

## 插入排序

**插入排序**是最直观的排序算法之一，它由N-1趟排序过程完成，从第p=1到N-1趟，插入排序保证从位置0到p的元素处于已排序状态。因此，插入排序利用了这样一个事实：在第p趟排序前，位置0到p-1的元素已经处于排序状态，第p趟需要在0到p的元素中选择一个合适的位置，放置元素p。随着排序的推进，已排序区的范围扩大，最终整个数组完成排序。

插入合适位置的策略是，在第p趟，将所有大于第p+1个元素的元素向左移动。

{% highlight golang linenos %}
//go insert sort
func InsertSort(nums []int) {
	var j int
	for p := 1; p < len(nums); p++ {
		tmp := nums[p]
		// mind the j scope
		for j = p; j > 0 && tmp < nums[j-1]; j-- {
			nums[j] = nums[j-1]
		}
		nums[j] = tmp
	}
}
{% endhighlight %}

当输入数组是反序时，插入排序的时间复杂度达到最高$O(N^2)$，当输入数组几乎被排序时，插入排序可以很快完成，到达$O(N)$。

## 冒泡排序

**冒泡排序**的思路是通过N-1趟遍历，每次比较两个元素，每趟将最小的一个元素传递到最前，形成一个顺序区，最终所有元素都与其邻居保持顺序，完成排序。

稍作优化的是，若在一轮遍历中，没有发现需要冒泡的逆序对，整个数组就认定为完成排序了。

{% highlight golang linenos %}
//bubble sort
func BubbleSort(nums []int) {
	for i := 0; i < len(nums)-1; i++ {
		var doSwap bool //if no swap done in this loop, the whole array must be in-order
		for j := len(nums) - 1; j > 0; j-- {
			if nums[j-1] > nums[j] {
				doSwap = true
				nums[j], nums[j-1] = nums[j-1], nums[j] //bubble up
			}
		}

		if !doSwap {
			break
		}
	}
}
{% endhighlight %}

冒泡排序和插入排序一样，在处理反序数组时需要$O(N^2)$的时间复杂度，而几乎排序好的数组只需要$O(N)$。

{% highlight golang linenos %}
{% endhighlight %}